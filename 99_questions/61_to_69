<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="generator" content="MediaWiki 1.19.5-1+deb7u1" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/haskellwiki/opensearch_desc.php" title="HaskellWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://www.haskell.org/haskellwiki/api.php?action=rsd" />
<link rel="copyright" href="/haskellwiki/HaskellWiki:Copyrights" />
<link rel="alternate" type="application/atom+xml" title="HaskellWiki Atom feed" href="/haskellwiki/index.php?title=Special:RecentChanges&amp;feed=atom" />		<title>99 questions/61 to 69 - HaskellWiki</title>
		<style type="text/css" media="screen, projection">/*<![CDATA[*/
			@import "/wikistatic/skins//common/shared.css?303";
			@import "/wikistatic/skins//hawiki/main.css?303";
		/*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print" href="/wikistatic/skins//common/commonPrint.css?303" />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/wikistatic/skins//hawiki/IE50Fixes.css?303";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/wikistatic/skins//hawiki/IE55Fixes.css?303";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/wikistatic/skins//hawiki/IE60Fixes.css?303";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/wikistatic/skins//hawiki/IE70Fixes.css?303";</style><![endif]-->
		<!--[if lte IE 7]><script type="text/javascript" src="/wikistatic/skins//hawiki/IEFixes.js?303"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
                                                <script type="text/javascript">
                        var isMSIE55 = (window.showModalDialog && window.clipboardData && window.createPopup); /*alert("test: " + isMSIE55);*/</script>

		<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"99_questions/61_to_69","wgTitle":"99 questions/61 to 69","wgCurRevisionId":37691,"wgArticleId":2471,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Tutorials"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgRelevantPageName":"99_questions/61_to_69","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script>
		<script type="text/javascript" src="/wikistatic/skins//common/wikibits.js?303"><!-- wikibits js --></script>
		<!-- Head Scripts -->
<script src="http://www.haskell.org/haskellwiki/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=hawiki&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"99_questions/61_to_69","wgTitle":"99 questions/61 to 69","wgCurRevisionId":37691,"wgArticleId":2471,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Tutorials"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgRelevantPageName":"99_questions/61_to_69","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":1,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"hawiki","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;},{},{});mw.loader.implement("user.tokens",function($){mw.user.tokens.set({"editToken":"+\\","watchToken":false});;},{},{});

/* cache key: wikidb:resourceloader:filter:minify-js:7:befcdb5e3b24ff89f900613de9ed4ea3 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script><style type="text/css">/*<![CDATA[*/
.source-haskell {line-height: normal;}
.source-haskell li, .source-haskell pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for haskell
 * CSS class: source-haskell, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.haskell.source-haskell .de1, .haskell.source-haskell .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.haskell.source-haskell  {font-family:monospace;}
.haskell.source-haskell .imp {font-weight: bold; color: red;}
.haskell.source-haskell li, .haskell.source-haskell .li1 {font-weight: normal; vertical-align:top;}
.haskell.source-haskell .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.haskell.source-haskell .li2 {font-weight: bold; vertical-align:top;}
.haskell.source-haskell .kw1 {color: #06c; font-weight: bold;}
.haskell.source-haskell .kw2 {color: #06c; font-weight: bold;}
.haskell.source-haskell .kw3 {font-weight: bold;}
.haskell.source-haskell .kw4 {color: #cccc00; font-weight: bold;}
.haskell.source-haskell .kw5 {color: maroon;}
.haskell.source-haskell .co1 {color: #5d478b; font-style: italic;}
.haskell.source-haskell .co2 {color: #339933; font-weight: bold;}
.haskell.source-haskell .coMULTI {color: #5d478b; font-style: italic;}
.haskell.source-haskell .es0 {background-color: #3cb371; font-weight: bold;}
.haskell.source-haskell .br0 {color: green;}
.haskell.source-haskell .sy0 {color: #339933; font-weight: bold;}
.haskell.source-haskell .st0 {background-color: #3cb371;}
.haskell.source-haskell .nu0 {color: red;}
.haskell.source-haskell .me1 {color: #060;}
.haskell.source-haskell .ln-xtra, .haskell.source-haskell li.ln-xtra, .haskell.source-haskell div.ln-xtra {background-color: #ffc;}
.haskell.source-haskell span.xtra { display:block; }

/*]]>*/
</style>	</head>
<body class="mediawiki ltr ns-0 ns-subject page-99_questions_61_to_69 skin-hawiki">
   <div id="topbar" class="noprint">
	<div class="portlet noprint" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul><li><a class="homebutton" href="/haskellwiki/Haskell">Home</a></li>
				<li id="pt-login"><a href="/haskellwiki/index.php?title=Special:UserLogin&amp;returnto=99+questions%2F61+to+69">Log in</a></li>
			</ul>
		</div>
	</div>
        	  <div id="p-search">
	    <div id="searchBody" class="pBody">
	       <form action="/haskellwiki/index.php" id="searchform"><div>
	          <input type='hidden' name="title" value="Special:Search"/>
	          <input id="searchInput" name="search" type="text" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" />

	         </div></form>
	    </div>
	  </div>
   </div>
	<div id="globalWrapper">
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/wikistatic/haskellwiki_logo.png);" href="/haskellwiki/Haskell"></a>
	</div>
	<div id="column-content">
        <div id="notice-area" class="noprint">
        <!-- ?php $this->data['sitenotice'] = 'This is a test instance.  Do not edit, your changes will be lost.'; ? -->
			        </div>
        <div id="content-wrapper">
	<div id="p-cactions" class="portlet noprint">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/haskellwiki/99_questions/61_to_69">Page</a></li>
				 <li id="ca-talk" class="new"><a href="/haskellwiki/index.php?title=Talk:99_questions/61_to_69&amp;action=edit&amp;redlink=1">Discussion</a></li>
				 <li id="ca-viewsource"><a href="/haskellwiki/index.php?title=99_questions/61_to_69&amp;action=edit">View source</a></li>
				 <li id="ca-history"><a href="/haskellwiki/index.php?title=99_questions/61_to_69&amp;action=history">History</a></li>			</ul>
		</div>
	</div>
                        <div id="content">
		<a name="top" id="top"></a>
                        <h1 id="firstHeading" class="firstHeading">99 questions/61 to 69</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From HaskellWiki</h3>
			<div id="contentSub"><span class="subpages">&lt; <a href="/haskellwiki/99_questions" title="99 questions">99 questions</a></span></div>
			<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p><br />
This is part of <a href="/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems" title="H-99: Ninety-Nine Haskell Problems">Ninety-Nine Haskell Problems</a>, based on <a rel="nofollow" class="external text" href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">Ninety-Nine Prolog Problems</a>.
</p>
<h2> <span class="mw-headline" id="Binary_trees">1  Binary trees </span></h2>
<p>As defined in problem 54A.
</p><p>An example tree:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">tree4 <span class="sy0">=</span> Branch <span class="nu0">1</span> <span class="br0">&#40;</span>Branch <span class="nu0">2</span> Empty <span class="br0">&#40;</span>Branch <span class="nu0">4</span> Empty Empty<span class="br0">&#41;</span><span class="br0">&#41;</span>
                 <span class="br0">&#40;</span>Branch <span class="nu0">2</span> Empty Empty<span class="br0">&#41;</span></pre></div></div>
<h2> <span class="mw-headline" id="Problem_61">2  Problem 61 </span></h2>
<p>Count the leaves of a binary tree
</p><p>A leaf is a node with no successors. Write a predicate count_leaves/2 to count them.
</p><p>Example:
</p>
<pre>
% count_leaves(T,N)&#160;:- the binary tree T has N leaves
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="sy0">&gt;</span> countLeaves tree4
<span class="nu0">2</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/61" title="99 questions/Solutions/61"> Solutions</a>
</p>
<h2> <span class="mw-headline" id="Problem_61A">3  Problem 61A </span></h2>
<p>Collect the leaves of a binary tree in a list
</p><p>A leaf is a node with no successors. Write a predicate leaves/2 to collect them in a list.
</p><p>Example:
</p>
<pre>
% leaves(T,S)&#160;:- S is the list of all leaves of the binary tree T
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="sy0">&gt;</span> leaves tree4
<span class="br0">&#91;</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#93;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/61A" title="99 questions/Solutions/61A"> Solutions</a>
</p>
<h2> <span class="mw-headline" id="Problem_62">4  Problem 62 </span></h2>
<p>Collect the internal nodes of a binary tree in a list 
</p><p>An internal node of a binary tree has either one or two non-empty successors. Write a predicate internals/2 to collect them in a list. 
</p><p>Example:
</p>
<pre>
% internals(T,S)&#160;:- S is the list of internal nodes of the binary tree T.
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">Prelude<span class="sy0">&gt;</span>internals tree4
Prelude<span class="sy0">&gt;</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#93;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/62" title="99 questions/Solutions/62"> Solutions</a>
</p><p><br />
</p>
<h2> <span class="mw-headline" id="Problem_62B">5  Problem 62B </span></h2>
<p>Collect the nodes at a given level in a list
</p><p>A node of a binary tree is at level N if the path from the root to the node has length N-1. The root node is at level 1. Write a predicate atlevel/3 to collect all nodes at a given level in a list. 
</p><p>Example:
</p>
<pre>
% atlevel(T,L,S)&#160;:- S is the list of nodes of the binary tree T at level L
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">Prelude<span class="sy0">&gt;</span>atLevel tree4 <span class="nu0">2</span>
Prelude<span class="sy0">&gt;</span><span class="br0">&#91;</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#93;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/62B" title="99 questions/Solutions/62B"> Solutions</a>
</p>
<h2> <span class="mw-headline" id="Problem_63">6  Problem 63 </span></h2>
<p>Construct a complete binary tree
</p><p>A complete binary tree with height H is defined as follows:
</p>
<ul><li> The levels 1,2,3,...,H-1 contain the maximum number of nodes (i.e 2**(i-1) at the level i)
</li><li> In level H, which may contain less than the maximum possible number of nodes, all the nodes are "left-adjusted". This means that in a levelorder tree traversal all internal nodes come first, the leaves come second, and empty successors (the nil's which are not really nodes!) come last.                                                                                                                                      
</li></ul>
<p>Particularly, complete binary trees are used as data structures (or addressing schemes) for heaps.                                                             
</p><p>We can assign an address number to each node in a complete binary tree by enumerating the nodes in level-order, starting at the root with number 1. For every node X with address A the following property holds: The address of X's left and right successors are 2*A and 2*A+1, respectively, if they exist. This fact can be used to elegantly construct a complete binary tree structure.
</p><p>Write a predicate complete_binary_tree/2.
</p><p>Example:
</p>
<pre>
% complete_binary_tree(N,T)&#160;:- T is a complete binary tree with N nodes.
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">Main<span class="sy0">&gt;</span> completeBinaryTree <span class="nu0">4</span>
Branch 'x' <span class="br0">&#40;</span>Branch 'x' <span class="br0">&#40;</span>Branch 'x' Empty Empty<span class="br0">&#41;</span> Empty<span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch 'x' Empty Empty<span class="br0">&#41;</span>
&#160;
Main<span class="sy0">&gt;</span> isCompleteBinaryTree <span class="sy0">$</span> Branch 'x' <span class="br0">&#40;</span>Branch 'x' Empty Empty<span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch 'x' Empty Empty<span class="br0">&#41;</span>
True</pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/63" title="99 questions/Solutions/63"> Solutions</a>
</p>
<h2> <span class="mw-headline" id="Problem_64">7  Problem 64 </span></h2>
<p>Given a binary tree as the usual Prolog term t(X,L,R) (or nil). As a preparation for drawing the tree, a layout algorithm is required to determine the position of each node in a rectangular grid. Several layout methods are conceivable, one of them is shown in the illustration below:
</p><p><img src="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/p64.gif" alt="p64.gif" />
</p><p>In this layout strategy, the position of a node v is obtained by the following two rules:
</p>
<ul><li> x(v) is equal to the position of the node v in the inorder sequence
</li><li> y(v) is equal to the depth of the node v in the tree
</li></ul>
<p>Write a function to annotate each node of the tree with a position, where (1,1) in the top left corner or the rectangle bounding the drawn tree.
</p><p>Here is the example tree from the above illustration:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">tree64 <span class="sy0">=</span> Branch 'n'
                <span class="br0">&#40;</span>Branch 'k'
                        <span class="br0">&#40;</span>Branch 'c'
                                <span class="br0">&#40;</span>Branch 'a' Empty Empty<span class="br0">&#41;</span>
                                <span class="br0">&#40;</span>Branch 'h'
                                        <span class="br0">&#40;</span>Branch 'g'
                                                <span class="br0">&#40;</span>Branch 'e' Empty Empty<span class="br0">&#41;</span>
                                                Empty
                                        <span class="br0">&#41;</span>
                                        Empty
                                <span class="br0">&#41;</span>
                        <span class="br0">&#41;</span>
                        <span class="br0">&#40;</span>Branch 'm' Empty Empty<span class="br0">&#41;</span>
                <span class="br0">&#41;</span>
                <span class="br0">&#40;</span>Branch 'u'
                        <span class="br0">&#40;</span>Branch 'p'
                                Empty
                                <span class="br0">&#40;</span>Branch 's'
                                        <span class="br0">&#40;</span>Branch 'q' Empty Empty<span class="br0">&#41;</span>
                                        Empty
                                <span class="br0">&#41;</span>
                        <span class="br0">&#41;</span>
                        Empty
                <span class="br0">&#41;</span></pre></div></div>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="sy0">&gt;</span> layout tree64
Branch <span class="br0">&#40;</span>'n'<span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">8</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch <span class="br0">&#40;</span>'k'<span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">6</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch <span class="br0">&#40;</span>'c'<span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">...</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/64" title="99 questions/Solutions/64"> Solutions</a>
</p><p><br />        
</p>
<h2> <span class="mw-headline" id="Problem_65">8  Problem 65 </span></h2>
<p>An alternative layout method is depicted in the illustration below:
</p><p><img src="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/p65.gif" alt="p65.gif" />
</p><p>Find out the rules and write the corresponding function.
Hint: On a given level, the horizontal distance between neighboring nodes is constant.
</p><p>Use the same conventions as in problem P64 and test your function in an appropriate way.
</p><p>Here is the example tree from the above illustration:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">tree65 <span class="sy0">=</span> Branch 'n'
                <span class="br0">&#40;</span>Branch 'k'
                        <span class="br0">&#40;</span>Branch 'c'
                                <span class="br0">&#40;</span>Branch 'a' Empty Empty<span class="br0">&#41;</span>
                                <span class="br0">&#40;</span>Branch 'e'
                                        <span class="br0">&#40;</span>Branch 'd' Empty Empty<span class="br0">&#41;</span>
                                        <span class="br0">&#40;</span>Branch 'g' Empty Empty<span class="br0">&#41;</span>
                                <span class="br0">&#41;</span>
                        <span class="br0">&#41;</span>
                        <span class="br0">&#40;</span>Branch 'm' Empty Empty<span class="br0">&#41;</span>
                <span class="br0">&#41;</span>
                <span class="br0">&#40;</span>Branch 'u'
                        <span class="br0">&#40;</span>Branch 'p'
                                Empty
                                <span class="br0">&#40;</span>Branch 'q' Empty Empty<span class="br0">&#41;</span>
                        <span class="br0">&#41;</span>
                        Empty
                <span class="br0">&#41;</span></pre></div></div>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="sy0">&gt;</span> layout tree65
Branch <span class="br0">&#40;</span>'n'<span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">15</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch <span class="br0">&#40;</span>'k'<span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">7</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch <span class="br0">&#40;</span>'c'<span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">...</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/65" title="99 questions/Solutions/65"> Solutions</a>
</p><p><br />
</p>
<h2> <span class="mw-headline" id="Problem_66">9  Problem 66 </span></h2>
<p>Yet another layout strategy is shown in the illustration below:
</p><p><img src="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/p66.gif" alt="p66.gif" />
</p><p>The method yields a very compact layout while maintaining a certain symmetry in every node. Find out the rules and write the corresponding Prolog predicate. Hint: Consider the horizontal distance between a node and its successor nodes. How tight can you pack together two subtrees to construct the combined binary tree?
</p><p>Use the same conventions as in problem P64 and P65 and test your predicate in an appropriate way. Note: This is a difficult problem. Don't give up too early!
</p><p>Which layout do you like most?
</p><p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="sy0">&gt;</span> layout tree65
Branch <span class="br0">&#40;</span>'n'<span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch <span class="br0">&#40;</span>'k'<span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch <span class="br0">&#40;</span>'c'<span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">...</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/66" title="99 questions/Solutions/66"> Solutions</a>
</p><p><br />
</p>
<h2> <span class="mw-headline" id="Problem_67A">10  Problem 67A </span></h2>
<p>A string representation of binary trees
</p><p>Somebody represents binary trees as strings of the following type:
</p>
<dl><dd>a(b(d,e),c(,f(g,)))
</dd></dl>
<p>a) Write a Prolog predicate which generates this string representation, if the tree is given as usual (as nil or t(X,L,R) term). Then write a predicate which does this inverse; i.e. given the string representation, construct the tree in the usual form. Finally, combine the two predicates in a single predicate tree_string/2 which can be used in both directions.
</p><p>Example in Prolog
</p>
<pre>
?- tree_to_string(t(x,t(y,nil,nil),t(a,nil,t(b,nil,nil))),S).
S = 'x(y,a(,b))'
?- string_to_tree('x(y,a(,b))',T).
T = t(x, t(y, nil, nil), t(a, nil, t(b, nil, nil)))
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">Main<span class="sy0">&gt;</span> stringToTree <span class="st0">&quot;x(y,a(,b))&quot;</span> <span class="sy0">&gt;&gt;=</span> <span class="kw3">print</span>
Branch 'x' <span class="br0">&#40;</span>Branch 'y' Empty Empty<span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch 'a' Empty <span class="br0">&#40;</span>Branch 'b' Empty Empty<span class="br0">&#41;</span><span class="br0">&#41;</span>
Main<span class="sy0">&gt;</span> <span class="kw1">let</span> t <span class="sy0">=</span> cbtFromList <span class="br0">&#91;</span>'a'<span class="sy0">..</span>'z'<span class="br0">&#93;</span> <span class="kw1">in</span> stringToTree <span class="br0">&#40;</span>treeToString t<span class="br0">&#41;</span> <span class="sy0">&gt;&gt;=</span> <span class="kw3">print</span> <span class="sy0">.</span> <span class="br0">&#40;</span><span class="sy0">==</span> t<span class="br0">&#41;</span>
True</pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/67A" title="99 questions/Solutions/67A"> Solutions</a>
</p><p><br />        
</p>
<h2> <span class="mw-headline" id="Problem_68">11  Problem 68 </span></h2>
<p>Preorder and inorder sequences of binary trees. We consider binary trees with nodes that are identified by single lower-case letters, as in the example of problem P67.
</p><p>a) Write predicates preorder/2 and inorder/2 that construct the preorder and inorder sequence of a given binary tree, respectively. The results should be atoms, e.g. 'abdecfg' for the preorder sequence of the example in problem P67.
</p><p>b) Can you use preorder/2 from problem part a) in the reverse direction; i.e. given a preorder sequence, construct a corresponding tree? If not, make the necessary arrangements.
</p><p>c) If both the preorder sequence and the inorder sequence of the nodes of a binary tree are given, then the tree is determined unambiguously. Write a predicate pre_in_tree/3 that does the job.
</p><p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">Main<span class="sy0">&gt;</span> <span class="kw1">let</span> <span class="br0">&#123;</span> Just t <span class="sy0">=</span> stringToTree <span class="st0">&quot;a(b(d,e),c(,f(g,)))&quot;</span>&#160;;
            po <span class="sy0">=</span> treeToPreorder t&#160;;
            io <span class="sy0">=</span> treeToInorder t <span class="br0">&#125;</span> <span class="kw1">in</span> preInTree po io <span class="sy0">&gt;&gt;=</span> <span class="kw3">print</span>
Branch 'a' <span class="br0">&#40;</span>Branch 'b' <span class="br0">&#40;</span>Branch 'd' Empty Empty<span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch 'e' Empty Empty<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch 'c' Empty <span class="br0">&#40;</span>Branch 'f' <span class="br0">&#40;</span>Branch 'g' Empty Empty<span class="br0">&#41;</span> Empty<span class="br0">&#41;</span><span class="br0">&#41;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/68" title="99 questions/Solutions/68"> Solutions</a>
</p><p><br />        
</p>
<h2> <span class="mw-headline" id="Problem_69">12  Problem 69 </span></h2>
<p>Dotstring representation of binary trees.
</p><p>We consider again binary trees with nodes that are identified by single lower-case letters, as in the example of problem P67. Such a tree can be represented by the preorder sequence of its nodes in which dots (.) are inserted where an empty subtree (nil) is encountered during the tree traversal. For example, the tree shown in problem P67 is represented as 'abd..e..c.fg...'. First, try to establish a syntax (BNF or syntax diagrams) and then write a predicate tree_dotstring/2 which does the conversion in both directions. Use 
difference lists.
</p><p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="sy0">&gt;</span> <span class="kw3">fst</span> <span class="br0">&#40;</span>ds2tree example<span class="br0">&#41;</span>
Branch 'a' <span class="br0">&#40;</span>Branch 'b' <span class="br0">&#40;</span>Branch 'd' Empty Empty<span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch 'e' Empty Empty<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch 'c' Empty <span class="br0">&#40;</span>Branch 'f' <span class="br0">&#40;</span>Branch 'g' Empty Empty<span class="br0">&#41;</span> Empty<span class="br0">&#41;</span><span class="br0">&#41;</span>
&#160;
<span class="sy0">&gt;</span> tree2ds <span class="br0">&#40;</span>Branch 'x' <span class="br0">&#40;</span>Branch 'y' Empty Empty<span class="br0">&#41;</span> <span class="br0">&#40;</span>Branch 'z' <span class="br0">&#40;</span>Branch '<span class="nu0">0</span>' Empty Empty<span class="br0">&#41;</span> Empty<span class="br0">&#41;</span><span class="br0">&#41;</span>
<span class="st0">&quot;xy..z0...&quot;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/69" title="99 questions/Solutions/69"> Solutions</a>
</p>
<!-- 
NewPP limit report
Preprocessor node count: 221/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2471-0!*!0!1!*!*!* and timestamp 20141003022131 -->
</div><div class="printfooter">
Retrieved from "<a href="http://www.haskell.org/haskellwiki/index.php?title=99_questions/61_to_69&amp;oldid=37691">http://www.haskell.org/haskellwiki/index.php?title=99_questions/61_to_69&amp;oldid=37691</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/haskellwiki/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="/haskellwiki/Category:Tutorials" title="Category:Tutorials">Tutorials</a></li></ul></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div></div>
		<div id="column-one">
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage"><a href="/haskellwiki/Haskell">Haskell</a></li>
				<li id="n-portal"><a href="/haskellwiki/HaskellWiki:Community">Wiki community</a></li>
				<li id="n-recentchanges"><a href="/haskellwiki/Special:RecentChanges">Recent changes</a></li>
				<li id="n-randompage"><a href="/haskellwiki/Special:Random">Random page</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/haskellwiki/Special:WhatLinksHere/99_questions/61_to_69">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/haskellwiki/Special:RecentChangesLinked/99_questions/61_to_69">Related changes</a></li>
<li id="t-specialpages"><a href="/haskellwiki/Special:SpecialPages">Special pages</a></li>
				<li id="t-print"><a href="/haskellwiki/index.php?title=99_questions/61_to_69&amp;printable=yes" rel="alternate">Printable version</a></li>				<li id="t-permalink"><a href="/haskellwiki/index.php?title=99_questions/61_to_69&amp;oldid=37691">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="//www.mediawiki.org/"><img src="/wikistatic/skins//common/images/poweredby_mediawiki_88x31.png" height="31" width="88" alt="Powered by MediaWiki" /></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 2 December 2010, at 08:51.</li>
					<li id="viewcount">This page has been accessed 31,411 times.</li>
					<li id="copyright">Recent content is available under <a href="/haskellwiki/HaskellWiki:Copyrights" title="HaskellWiki:Copyrights">a simple permissive license</a>.</li>
					<li id="privacy"><a href="/haskellwiki/HaskellWiki:Privacy_policy" title="HaskellWiki:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/haskellwiki/HaskellWiki:About" title="HaskellWiki:About">About HaskellWiki</a></li>
					<li id="disclaimer"><a href="/haskellwiki/HaskellWiki:General_disclaimer" title="HaskellWiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>
<script>if(window.mw){
mw.loader.load(["mediawiki.user","mediawiki.page.ready"], null, true);
}</script>
<script src="http://www.haskell.org/haskellwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=hawiki&amp;*"></script>
<!-- Served in 0.120 secs. --><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-15375175-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body></html>
