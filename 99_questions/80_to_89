<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="generator" content="MediaWiki 1.19.5-1+deb7u1" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/haskellwiki/opensearch_desc.php" title="HaskellWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://www.haskell.org/haskellwiki/api.php?action=rsd" />
<link rel="copyright" href="/haskellwiki/HaskellWiki:Copyrights" />
<link rel="alternate" type="application/atom+xml" title="HaskellWiki Atom feed" href="/haskellwiki/index.php?title=Special:RecentChanges&amp;feed=atom" />		<title>99 questions/80 to 89 - HaskellWiki</title>
		<style type="text/css" media="screen, projection">/*<![CDATA[*/
			@import "/wikistatic/skins//common/shared.css?303";
			@import "/wikistatic/skins//hawiki/main.css?303";
		/*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print" href="/wikistatic/skins//common/commonPrint.css?303" />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/wikistatic/skins//hawiki/IE50Fixes.css?303";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/wikistatic/skins//hawiki/IE55Fixes.css?303";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/wikistatic/skins//hawiki/IE60Fixes.css?303";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/wikistatic/skins//hawiki/IE70Fixes.css?303";</style><![endif]-->
		<!--[if lte IE 7]><script type="text/javascript" src="/wikistatic/skins//hawiki/IEFixes.js?303"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
                                                <script type="text/javascript">
                        var isMSIE55 = (window.showModalDialog && window.clipboardData && window.createPopup); /*alert("test: " + isMSIE55);*/</script>

		<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"99_questions/80_to_89","wgTitle":"99 questions/80 to 89","wgCurRevisionId":57145,"wgArticleId":2473,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Tutorials"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgRelevantPageName":"99_questions/80_to_89","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script>
		<script type="text/javascript" src="/wikistatic/skins//common/wikibits.js?303"><!-- wikibits js --></script>
		<!-- Head Scripts -->
<script src="http://www.haskell.org/haskellwiki/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=hawiki&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"99_questions/80_to_89","wgTitle":"99 questions/80 to 89","wgCurRevisionId":57145,"wgArticleId":2473,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Tutorials"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgRelevantPageName":"99_questions/80_to_89","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":1,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"hawiki","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;},{},{});mw.loader.implement("user.tokens",function($){mw.user.tokens.set({"editToken":"+\\","watchToken":false});;},{},{});

/* cache key: wikidb:resourceloader:filter:minify-js:7:befcdb5e3b24ff89f900613de9ed4ea3 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script><style type="text/css">/*<![CDATA[*/
.source-haskell {line-height: normal;}
.source-haskell li, .source-haskell pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for haskell
 * CSS class: source-haskell, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.haskell.source-haskell .de1, .haskell.source-haskell .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.haskell.source-haskell  {font-family:monospace;}
.haskell.source-haskell .imp {font-weight: bold; color: red;}
.haskell.source-haskell li, .haskell.source-haskell .li1 {font-weight: normal; vertical-align:top;}
.haskell.source-haskell .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.haskell.source-haskell .li2 {font-weight: bold; vertical-align:top;}
.haskell.source-haskell .kw1 {color: #06c; font-weight: bold;}
.haskell.source-haskell .kw2 {color: #06c; font-weight: bold;}
.haskell.source-haskell .kw3 {font-weight: bold;}
.haskell.source-haskell .kw4 {color: #cccc00; font-weight: bold;}
.haskell.source-haskell .kw5 {color: maroon;}
.haskell.source-haskell .co1 {color: #5d478b; font-style: italic;}
.haskell.source-haskell .co2 {color: #339933; font-weight: bold;}
.haskell.source-haskell .coMULTI {color: #5d478b; font-style: italic;}
.haskell.source-haskell .es0 {background-color: #3cb371; font-weight: bold;}
.haskell.source-haskell .br0 {color: green;}
.haskell.source-haskell .sy0 {color: #339933; font-weight: bold;}
.haskell.source-haskell .st0 {background-color: #3cb371;}
.haskell.source-haskell .nu0 {color: red;}
.haskell.source-haskell .me1 {color: #060;}
.haskell.source-haskell .ln-xtra, .haskell.source-haskell li.ln-xtra, .haskell.source-haskell div.ln-xtra {background-color: #ffc;}
.haskell.source-haskell span.xtra { display:block; }

/*]]>*/
</style>	</head>
<body class="mediawiki ltr ns-0 ns-subject page-99_questions_80_to_89 skin-hawiki">
   <div id="topbar" class="noprint">
	<div class="portlet noprint" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul><li><a class="homebutton" href="/haskellwiki/Haskell">Home</a></li>
				<li id="pt-login"><a href="/haskellwiki/index.php?title=Special:UserLogin&amp;returnto=99+questions%2F80+to+89">Log in</a></li>
			</ul>
		</div>
	</div>
        	  <div id="p-search">
	    <div id="searchBody" class="pBody">
	       <form action="/haskellwiki/index.php" id="searchform"><div>
	          <input type='hidden' name="title" value="Special:Search"/>
	          <input id="searchInput" name="search" type="text" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" />

	         </div></form>
	    </div>
	  </div>
   </div>
	<div id="globalWrapper">
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/wikistatic/haskellwiki_logo.png);" href="/haskellwiki/Haskell"></a>
	</div>
	<div id="column-content">
        <div id="notice-area" class="noprint">
        <!-- ?php $this->data['sitenotice'] = 'This is a test instance.  Do not edit, your changes will be lost.'; ? -->
			        </div>
        <div id="content-wrapper">
	<div id="p-cactions" class="portlet noprint">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/haskellwiki/99_questions/80_to_89">Page</a></li>
				 <li id="ca-talk" class="new"><a href="/haskellwiki/index.php?title=Talk:99_questions/80_to_89&amp;action=edit&amp;redlink=1">Discussion</a></li>
				 <li id="ca-viewsource"><a href="/haskellwiki/index.php?title=99_questions/80_to_89&amp;action=edit">View source</a></li>
				 <li id="ca-history"><a href="/haskellwiki/index.php?title=99_questions/80_to_89&amp;action=history">History</a></li>			</ul>
		</div>
	</div>
                        <div id="content">
		<a name="top" id="top"></a>
                        <h1 id="firstHeading" class="firstHeading">99 questions/80 to 89</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From HaskellWiki</h3>
			<div id="contentSub"><span class="subpages">&lt; <a href="/haskellwiki/99_questions" title="99 questions">99 questions</a></span></div>
			<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p><br />
This is part of <a href="/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems" title="H-99: Ninety-Nine Haskell Problems">Ninety-Nine Haskell Problems</a>, based on <a rel="nofollow" class="external text" href="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/">Ninety-Nine Prolog Problems</a>.
</p><p>If you want to work on one of these, put your name in the block so we know someone's working on it. Then, change n in your block to the appropriate problem number, and fill in the &lt;Problem description&gt;,&lt;example in lisp&gt;,&lt;example in Haskell&gt;,&lt;solution in haskell&gt; and &lt;description of implementation&gt; fields. 
</p>
<h2> <span class="mw-headline" id="Graphs">1  Graphs </span></h2>
<p>A graph is defined as a set of nodes and a set of edges, where each edge is a pair of nodes. 
</p><p><img src="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/graph1.gif" alt="graph1.gif" />
</p><p>There are several ways to represent graphs in Prolog. One method is to represent each edge separately as one clause (fact). In this form, the graph depicted below is represented as the following predicate: 
</p>
<pre>edge(h,g).
edge(k,f).
edge(f,b).
...
</pre>
<p>We call this <i>edge-clause</i> form. Obviously, isolated nodes cannot be represented. Another method is to represent the whole graph as one data object. According to the definition of the graph as a pair of two sets (nodes and edges), we may use the following Prolog term to represent the example graph:
</p>
<pre>graph([b,c,d,f,g,h,k],[e(b,c),e(b,f),e(c,f),e(f,k),e(g,h)])
</pre>
<p>We call this <i>graph-term</i> form. Note, that the lists are kept sorted, they are really <i>sets</i>, without duplicated elements. Each edge appears only once in the edge list; i.e. an edge from a node x to another node y is represented as e(x,y), the term e(y,x) is not present. <b>The graph-term form is our default representation.</b> In SWI-Prolog there are predefined predicates to work with sets. 
</p><p>A third representation method is to associate with each node the set of nodes that are adjacent to that node. We call this the <i>adjacency-list</i> form. In our example:
</p>
<pre>[n(b,[c,f]), n(c,[b,f]), n(d,[]), n(f,[b,c,k]), ...]
</pre>
<p>The representations we introduced so far are Prolog terms and therefore well suited for automated processing, but their syntax is not very user-friendly. Typing the terms by hand is cumbersome and error-prone. We can define a more compact and "human-friendly" notation as follows: A graph is represented by a list of atoms and terms of the type X-Y (i.e. functor '-' and arity 2). The atoms stand for isolated nodes, the X-Y terms describe edges. If an X appears as an endpoint of an edge, it is automatically defined as a node. Our example could be written as:
</p>
<pre>[b-c, f-c, g-h, d, f-b, k-f, h-g]
</pre>
<p>We call this the <i>human-friendly</i> form. As the example shows, the list does not have to be sorted and may even contain the same edge multiple times. Notice the isolated node d. (Actually, isolated nodes do not even have to be atoms in the Prolog sense, they can be compound terms, as in <tt>d(3.75,blue)</tt> instead of <tt>d</tt> in the example). 
</p><p><img src="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/graph2.gif" alt="graph2.gif" />
</p><p>When the edges are directed we call them arcs. These are represented by ordered pairs. Such a graph is called <b>directed graph</b>. To represent a directed graph, the forms discussed above are slightly modified. The example graph above is represented as follows: 
</p><p><i>Arc-clause form</i>
</p>
<pre>arc(s,u).
arc(u,r).
...
</pre>
<p><i>Graph-term form</i>
</p>
<pre>digraph([r,s,t,u,v],[a(s,r),a(s,u),a(u,r),a(u,s),a(v,u)])
</pre>
<p><i>Adjacency-list form</i>
</p>
<pre>[n(r,[]),n(s,[r,u]),n(t,[]),n(u,[r]),n(v,[u])]
</pre>
<p>Note that the adjacency-list does not have the information on whether it is a graph or a digraph.
</p><p><i>Human-friendly form</i>
</p>
<pre>[s &gt; r, t, u &gt; r, s &gt; u, u &gt; s, v &gt; u] 
</pre>
<p>Finally, graphs and digraphs may have additional information attached to nodes and edges (arcs). For the nodes, this is no problem, as we can easily replace the single character identifiers with arbitrary compound terms, such as <tt>city('London',4711)</tt>. On the other hand, for edges we have to extend our notation. Graphs with additional information attached to edges are called <b>labelled graphs</b>.
</p><p><img src="https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/graph3.gif" alt="graph3.gif" />
</p><p><i>Arc-clause form</i>
</p>
<pre>arc(m,q,7).
arc(p,q,9).
arc(p,m,5).
</pre>
<p><i>Graph-term form</i>
</p>
<pre>digraph([k,m,p,q],[a(m,p,7),a(p,m,5),a(p,q,9)])
</pre>
<p><i>Adjacency-list form</i>
</p>
<pre>[n(k,[]),n(m,[q/7]),n(p,[m/5,q/9]),n(q,[])]
</pre>
<p>Notice how the edge information has been packed into a term with functor '/' and arity 2, together with the corresponding node.
</p><p><i>Human-friendly form</i>
</p>
<pre>[p&gt;q/9, m&gt;q/7, k, p&gt;m/5]
</pre>
<p>The notation for labelled graphs can also be used for so-called <b>multi-graphs</b>, where more than one edge (or arc) are allowed between two given nodes.
</p>
<h2> <span class="mw-headline" id="Problem_80">2  Problem 80 </span></h2>
<p>(***) Conversions
</p><p>Write predicates to convert between the different graph representations. With these predicates, all representations are equivalent; i.e. for the following problems you can always pick freely the most convenient form. The reason this problem is rated (***) is not because it's particularly difficult, but because it's a lot of work to deal with all the special cases.
</p><p>Example:
</p>
<pre>
&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">graphToAdj Graph <span class="br0">&#91;</span>'b'<span class="sy0">,</span>'c'<span class="sy0">,</span>'d'<span class="sy0">,</span>'f'<span class="sy0">,</span>'g'<span class="sy0">,</span>'h'<span class="sy0">,</span>'k'<span class="br0">&#93;</span> <span class="br0">&#91;</span><span class="br0">&#40;</span>'b'<span class="sy0">,</span>'c'<span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span>'b'<span class="sy0">,</span>'f'<span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span>'c'<span class="sy0">,</span>'f'<span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span>'f'<span class="sy0">,</span>'k'<span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span>'g'<span class="sy0">,</span>'h'<span class="br0">&#41;</span><span class="br0">&#93;</span>
Adj <span class="br0">&#91;</span><span class="br0">&#40;</span>'b'<span class="sy0">,</span> <span class="st0">&quot;cf&quot;</span><span class="br0">&#41;</span><span class="sy0">,</span> <span class="br0">&#40;</span>'c'<span class="sy0">,</span> <span class="st0">&quot;bf&quot;</span><span class="br0">&#41;</span><span class="sy0">,</span> <span class="br0">&#40;</span>'d'<span class="sy0">,</span> <span class="st0">&quot;&quot;</span><span class="br0">&#41;</span><span class="sy0">,</span> <span class="br0">&#40;</span>'f'<span class="sy0">,</span> <span class="st0">&quot;bck&quot;</span><span class="br0">&#41;</span><span class="sy0">,</span> <span class="br0">&#40;</span>'g'<span class="sy0">,</span> <span class="st0">&quot;h&quot;</span><span class="br0">&#41;</span><span class="sy0">,</span> <span class="br0">&#40;</span>'h'<span class="sy0">,</span> <span class="st0">&quot;g&quot;</span><span class="br0">&#41;</span><span class="sy0">,</span> <span class="br0">&#40;</span>'k'<span class="sy0">,</span> <span class="st0">&quot;f&quot;</span><span class="br0">&#41;</span><span class="br0">&#93;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/80" title="99 questions/Solutions/80"> Solutions </a>
</p>
<h2> <span class="mw-headline" id="Problem_81">3  Problem 81 </span></h2>
<p>(**) Path from one node to another one
</p><p>Write a function that, given two nodes a and b in a graph, returns all the acyclic paths from a to b.
</p><p>Example:
</p>
<pre>
&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">paths <span class="nu0">1</span> <span class="nu0">4</span> <span class="br0">&#91;</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="br0">&#41;</span><span class="br0">&#93;</span>
<span class="br0">&#91;</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">&#93;</span><span class="sy0">,</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">&#93;</span><span class="br0">&#93;</span>
paths <span class="nu0">2</span> <span class="nu0">6</span> <span class="br0">&#91;</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="br0">&#41;</span><span class="br0">&#93;</span>
<span class="br0">&#91;</span><span class="br0">&#93;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/81" title="99 questions/Solutions/81"> Solutions </a>
</p>
<h2> <span class="mw-headline" id="Problem_82">4  Problem 82 </span></h2>
<p>(*) Cycle from a given node
</p><p>Write a predicate cycle(G,A,P) to find a closed path (cycle) P starting at a given node A in the graph G. The predicate should return all cycles via backtracking.
</p><p>Example:
</p>
<pre>
&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">graph<span class="sy0">&gt;</span> <span class="kw3">cycle</span> 2 <span class="br0">&#91;</span><span class="br0">&#40;</span>1<span class="sy0">,</span>2<span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span>2<span class="sy0">,</span>3<span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span>1<span class="sy0">,</span>3<span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span>3<span class="sy0">,</span>4<span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span>4<span class="sy0">,</span>2<span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span>5<span class="sy0">,</span>6<span class="br0">&#41;</span><span class="br0">&#93;</span>
<span class="br0">&#91;</span><span class="br0">&#91;</span>2<span class="sy0">,</span>3<span class="sy0">,</span>4<span class="sy0">,</span>2<span class="br0">&#93;</span><span class="br0">&#93;</span>
graph<span class="sy0">&gt;</span> <span class="kw3">cycle</span> <span class="nu0">1</span> <span class="br0">&#91;</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="sy0">,</span><span class="nu0">3</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">4</span><span class="sy0">,</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="br0">&#40;</span><span class="nu0">5</span><span class="sy0">,</span><span class="nu0">6</span><span class="br0">&#41;</span><span class="br0">&#93;</span>
<span class="br0">&#91;</span><span class="br0">&#93;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/82" title="99 questions/Solutions/82"> Solutions </a>
</p>
<h2> <span class="mw-headline" id="Problem_83">5  Problem 83 </span></h2>
<p>(**) Construct all spanning trees 
</p><p>Write a predicate s_tree(Graph,Tree) to construct (by backtracking) all spanning trees of a given graph. With this predicate, find out how many spanning trees there are for the graph depicted to the left. The data of this example graph can be found in the file p83.dat. When you have a correct solution for the s_tree/2 predicate, use it to define two other useful predicates: is_tree(Graph) and is_connected(Graph). Both are five-minutes tasks!
</p><p>Example:
</p>
<pre>
&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw3">length</span> <span class="sy0">$</span> spantree k4
<span class="nu0">16</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/83" title="99 questions/Solutions/83"> Solutions </a>
</p>
<h2> <span class="mw-headline" id="Problem_84">6  Problem 84 </span></h2>
<p>(**) Construct the minimal spanning tree
</p><p>Write a predicate ms_tree(Graph,Tree,Sum) to construct the minimal spanning tree of a given labelled graph. Hint: Use the algorithm of Prim. A small modification of the solution of P83 does the trick. The data of the example graph to the right can be found in the file p84.dat.
</p><p>Example:
</p>
<pre>
&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/84" title="99 questions/Solutions/84"> Solutions </a>
</p><p><br />        
</p>
<h2> <span class="mw-headline" id="Problem_85">7  Problem 85 </span></h2>
<p>(**) Graph isomorphism
</p><p>Two graphs G1(N1,E1) and G2(N2,E2) are isomorphic if there is a bijection f: N1 -&gt; N2 such that for any nodes X,Y of N1, X and Y are adjacent if and only if f(X) and f(Y) are adjacent.
</p><p>Write a predicate that determines whether two graphs are isomorphic. Hint: Use an open-ended list to represent the function f.
</p><p>Example:
</p>
<pre>
&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">iso graphG1 graphH1
True</pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/85" title="99 questions/Solutions/85"> Solutions </a>
</p>
<h2> <span class="mw-headline" id="Problem_86">8  Problem 86 </span></h2>
<p>(**) Node degree and graph coloration
</p><p>a) Write a predicate degree(Graph,Node,Deg) that determines the degree of a given node.
</p><p>b) Write a predicate that generates a list of all nodes of a graph sorted according to decreasing degree.
</p><p>c) Use Welch-Powell's algorithm to paint the nodes of a graph in such a way that adjacent nodes have different colors.
</p><p><br />
Example:
</p>
<pre>
&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">chromatic <span class="sy0">$</span> kcolor petersen
<span class="nu0">3</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/86" title="99 questions/Solutions/86"> Solutions </a>
</p>
<h2> <span class="mw-headline" id="Problem_87">9  Problem 87 </span></h2>
<p>(**) Depth-first order graph traversal (alternative solution)
</p><p>Write a predicate that generates a depth-first order graph traversal sequence. The starting point should be specified, and the output should be a list of nodes that are reachable from this starting point (in depth-first order).
</p><p>Example:
</p>
<pre>
&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/87" title="99 questions/Solutions/87"> Solutions </a>
</p><p><br />        
</p>
<h2> <span class="mw-headline" id="Problem_88">10  Problem 88 </span></h2>
<p>(**) Connected components (alternative solution)
</p><p>Write a predicate that splits a graph into its connected components.
</p><p>Example:
</p>
<pre>
&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/88" title="99 questions/Solutions/88"> Solutions </a>
</p><p><br />        
</p>
<h2> <span class="mw-headline" id="Problem_89">11  Problem 89 </span></h2>
<p>(**) Bipartite graphs
</p><p>Write a predicate that finds out whether a given graph is bipartite.
</p><p>Example:
</p>
<pre>
&lt;example in lisp&gt;
</pre>
<p>Example in Haskell:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="sy0">&lt;</span>example <span class="kw1">in</span> Haskell<span class="sy0">&gt;</span></pre></div></div>
<p><a href="/haskellwiki/99_questions/Solutions/89" title="99 questions/Solutions/89"> Solutions </a>
</p>
<!-- 
NewPP limit report
Preprocessor node count: 211/1000000
Postâ€expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:2473-0!*!0!1!*!*!* and timestamp 20141002073212 -->
</div><div class="printfooter">
Retrieved from "<a href="http://www.haskell.org/haskellwiki/index.php?title=99_questions/80_to_89&amp;oldid=57145">http://www.haskell.org/haskellwiki/index.php?title=99_questions/80_to_89&amp;oldid=57145</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/haskellwiki/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="/haskellwiki/Category:Tutorials" title="Category:Tutorials">Tutorials</a></li></ul></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div></div>
		<div id="column-one">
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage"><a href="/haskellwiki/Haskell">Haskell</a></li>
				<li id="n-portal"><a href="/haskellwiki/HaskellWiki:Community">Wiki community</a></li>
				<li id="n-recentchanges"><a href="/haskellwiki/Special:RecentChanges">Recent changes</a></li>
				<li id="n-randompage"><a href="/haskellwiki/Special:Random">Random page</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/haskellwiki/Special:WhatLinksHere/99_questions/80_to_89">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/haskellwiki/Special:RecentChangesLinked/99_questions/80_to_89">Related changes</a></li>
<li id="t-specialpages"><a href="/haskellwiki/Special:SpecialPages">Special pages</a></li>
				<li id="t-print"><a href="/haskellwiki/index.php?title=99_questions/80_to_89&amp;printable=yes" rel="alternate">Printable version</a></li>				<li id="t-permalink"><a href="/haskellwiki/index.php?title=99_questions/80_to_89&amp;oldid=57145">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="//www.mediawiki.org/"><img src="/wikistatic/skins//common/images/poweredby_mediawiki_88x31.png" height="31" width="88" alt="Powered by MediaWiki" /></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 22 November 2013, at 20:18.</li>
					<li id="viewcount">This page has been accessed 29,950 times.</li>
					<li id="copyright">Recent content is available under <a href="/haskellwiki/HaskellWiki:Copyrights" title="HaskellWiki:Copyrights">a simple permissive license</a>.</li>
					<li id="privacy"><a href="/haskellwiki/HaskellWiki:Privacy_policy" title="HaskellWiki:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/haskellwiki/HaskellWiki:About" title="HaskellWiki:About">About HaskellWiki</a></li>
					<li id="disclaimer"><a href="/haskellwiki/HaskellWiki:General_disclaimer" title="HaskellWiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>
<script>if(window.mw){
mw.loader.load(["mediawiki.user","mediawiki.page.ready"], null, true);
}</script>
<script src="http://www.haskell.org/haskellwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=hawiki&amp;*"></script>
<!-- Served in 0.090 secs. --><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-15375175-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body></html>
